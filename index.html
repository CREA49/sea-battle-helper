<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Sea Battle / GamePigeon Helper</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    :root {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #0b1020;
      color: #f5f5f5;
    }

    body {
      margin: 0;
      padding: 20px;
      display: flex;
      justify-content: center;
    }

    .app {
      max-width: 1100px;
      width: 100%;
      background: #151a30;
      border-radius: 16px;
      box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5);
      padding: 20px 24px 28px;
      box-sizing: border-box;
    }

    h1 {
      margin: 0;
      font-size: 1.6rem;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    h1 span {
      font-size: 1.05rem;
      color: #9ea7ff;
      font-weight: 500;
    }

    .subtitle {
      margin-top: 4px;
      color: #a0a6c4;
      font-size: 0.9rem;
    }

    .layout {
      display: grid;
      grid-template-columns: minmax(0, 2fr) minmax(0, 1.35fr);
      gap: 24px;
      margin-top: 20px;
    }

    @media (max-width: 900px) {
      .layout {
        grid-template-columns: 1fr;
      }
    }

    .panel {
      background: #1a2140;
      border-radius: 14px;
      padding: 14px 16px 16px;
      box-sizing: border-box;
      border: 1px solid #242b4d;
    }

    .panel h2 {
      margin: 0 0 6px;
      font-size: 1rem;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .panel small {
      color: #8d93b8;
      font-size: 0.8rem;
    }

    .controls-row {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      margin-bottom: 10px;
      align-items: center;
    }

    label {
      font-size: 0.85rem;
      color: #c3c7e8;
    }

    select,
    button,
    input[type="number"] {
      font-family: inherit;
      border-radius: 999px;
      border: 1px solid #343b65;
      background: #20264a;
      color: #f5f5f5;
      padding: 6px 12px;
      font-size: 0.85rem;
      outline: none;
      box-sizing: border-box;
    }

    input[type="number"] {
      width: 60px;
      text-align: center;
      -moz-appearance: textfield;
    }
    input[type="number"]::-webkit-outer-spin-button,
    input[type="number"]::-webkit-inner-spin-button {
      -webkit-appearance: none;
      margin: 0;
    }

    select:focus,
    button:focus,
    input[type="number"]:focus {
      border-color: #5b84ff;
      box-shadow: 0 0 0 1px rgba(91, 132, 255, 0.5);
    }

    button {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      border-radius: 999px;
      border: 1px solid #4650a8;
      background: linear-gradient(135deg, #3d4ef0, #7f5dff);
      cursor: pointer;
    }

    button.secondary {
      background: #20264a;
      border-color: #343b65;
    }

    button.mode-btn {
      background: #20264a;
      border-radius: 999px;
      padding: 5px 10px;
      border: 1px solid #343b65;
      font-size: 0.8rem;
    }

    button.mode-btn.active {
      background: #3d4ef0;
      border-color: #5b84ff;
    }

    .mode-buttons {
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
    }

    .legend {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      margin-top: 8px;
      font-size: 0.8rem;
      color: #9fa5d5;
    }

    .legend-item {
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }

    .legend-swatch {
      width: 14px;
      height: 14px;
      border-radius: 3px;
      border: 1px solid #343b65;
    }

    .board-wrapper {
      margin-top: 10px;
      overflow-x: auto;
      padding-bottom: 4px;
    }

    .board {
      display: grid;
      grid-template-columns: 24px repeat(10, 32px);
      grid-auto-rows: 24px;
      gap: 2px;
      user-select: none;
    }

    .board-size-8 {
      grid-template-columns: 24px repeat(8, 32px);
    }

    .board-size-9 {
      grid-template-columns: 24px repeat(9, 32px);
    }

    .board-size-10 {
      grid-template-columns: 24px repeat(10, 32px);
    }

    .board-header-cell,
    .board-row-label {
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.7rem;
      color: #8f95c4;
    }

    .cell {
      width: 32px;
      height: 32px;
      border-radius: 6px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.7rem;
      cursor: pointer;
      border: 1px solid #283054;
      box-sizing: border-box;
      position: relative;
      overflow: hidden;
    }

    .cell.unknown {
      background: #14182d;
    }

    .cell.miss {
      background: #2b324c;
      border-color: #3c4464;
    }

    .cell.hit {
      background: #ff4d6a;
      border-color: #ff98ae;
      color: #fff;
      font-weight: 600;
    }

    .cell.destroy {
      background: #24b36b;
      border-color: #6af3a1;
      color: #ffffff;
      font-weight: 700;
    }

    .cell.best {
      box-shadow: 0 0 0 2px #ffdd7f;
    }

    .cell-score {
      position: absolute;
      inset: 0;
      pointer-events: none;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.65rem;
      color: #fdfdfd;
      text-shadow: 0 1px 2px rgba(0, 0, 0, 0.9);
    }

    .cell-bg {
      position: absolute;
      inset: 0;
      border-radius: inherit;
      opacity: 0.85;
    }

    .ships-list {
      display: flex;
      flex-wrap: wrap;
      gap: 8px 12px;
      margin-top: 6px;
    }

    .ship-chip {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 4px 8px;
      border-radius: 999px;
      background: #20264a;
      border: 1px solid #343b65;
      font-size: 0.8rem;
    }

    .ship-chip span.len {
      font-weight: 500;
      color: #d4d8ff;
    }

    .ship-chip span.max {
      font-size: 0.75rem;
      color: #8f95c4;
    }

    .status {
      margin-top: 8px;
      font-size: 0.8rem;
      color: #9ea7ff;
    }

    .best-list {
      margin-top: 8px;
      font-size: 0.85rem;
      color: #d4d8ff;
    }

    .best-list span.coord {
      display: inline-block;
      padding: 3px 7px;
      margin-right: 6px;
      margin-bottom: 4px;
      border-radius: 999px;
      background: #252c55;
      border: 1px solid #3a4280;
      font-size: 0.78rem;
    }

    .footer-note {
      margin-top: 14px;
      font-size: 0.75rem;
      color: #7c83b0;
    }
  </style>
</head>
<body>
<div class="app">
  <h1>
    Sea Battle Helper
    <span>GamePigeon/Battleship solver (web port of the Python AI + sink logic)</span>
  </h1>
  <div class="subtitle">
    Match your Sea Battle board (hits, misses, sunk ships), set how many ships of each size are left, and this tool
    computes the same style of density map as the original Python A.I.
  </div>

  <div class="layout">
    <!-- LEFT: BOARD -->
    <div class="panel">
      <h2>
        Board
        <small>Click to mark cells. Use “Sink” on a hit when you sink a ship.</small>
      </h2>

      <div class="controls-row">
        <label>
          Board size:
          <select id="boardSizeSelect">
            <option value="8">8 × 8</option>
            <option value="9">9 × 9</option>
            <option value="10" selected>10 × 10</option>
          </select>
        </label>

        <div class="mode-buttons">
          <button type="button" class="mode-btn active" data-mode="miss">Miss</button>
          <button type="button" class="mode-btn" data-mode="hit">Hit</button>
          <button type="button" class="mode-btn" data-mode="sink">Sink</button>
          <button type="button" class="mode-btn" data-mode="clear">Clear</button>
        </div>

        <button type="button" id="resetBoardBtn" class="secondary">
          Reset board
        </button>
      </div>

      <div class="legend">
        <div class="legend-item">
          <span class="legend-swatch" style="background:#14182d;"></span> Unknown
        </div>
        <div class="legend-item">
          <span class="legend-swatch" style="background:#2b324c;"></span> Miss
        </div>
        <div class="legend-item">
          <span class="legend-swatch" style="background:#ff4d6a;"></span> Hit
        </div>
        <div class="legend-item">
          <span class="legend-swatch" style="background:#24b36b;"></span> Sunk ship
        </div>
        <div class="legend-item">
          <span class="legend-swatch" style="background:linear-gradient(135deg,#203a1f,#47c572);"></span> High probability
        </div>
      </div>

      <div class="board-wrapper">
        <div id="board" class="board board-size-10"></div>
      </div>
    </div>

    <!-- RIGHT: SHIPS + RESULTS -->
    <div class="panel">
      <h2>
        Ships & Best Shots
        <small>Matches Sea Battle fleets for 8×8, 9×9, 10×10.</small>
      </h2>

      <div style="font-size:0.85rem; color:#c3c7e8;">
        Fleet configuration (remaining ships):
      </div>
      <div class="ships-list" id="shipsList"></div>

      <div class="status" id="statusText">
        Waiting for board input…
      </div>

      <div class="best-list">
        <div style="margin-bottom:4px; font-weight:500;">Best shots:</div>
        <div id="bestShots"></div>
      </div>

      <div class="footer-note">
        Workflow: fire a shot → mark it as Miss or Hit. When you completely sink a ship in GamePigeon,
        switch to <b>Sink</b> mode and click one of that ship’s hit cells. The tool will mark the whole ship
        as sunk, auto-fill the “no-adjacent” misses around it, reduce the remaining ship count of that size,
        and update the density map.
      </div>
    </div>
  </div>
</div>

<script>
  // =======================
  // Constants & DOM refs
  // =======================

  const boardEl = document.getElementById("board");
  const boardSizeSelect = document.getElementById("boardSizeSelect");
  const resetBoardBtn = document.getElementById("resetBoardBtn");
  const shipsListEl = document.getElementById("shipsList");
  const statusText = document.getElementById("statusText");
  const bestShotsEl = document.getElementById("bestShots");
  const modeButtons = Array.from(document.querySelectorAll(".mode-btn"));

  // Board state:
  // 0 = unknown, 1 = miss, 2 = hit, 3 = destroyed/sunk
  let size = parseInt(boardSizeSelect.value, 10);
  let board = createEmptyBoard(size);
  let scores = createEmptyBoard(size);

  // Sea Battle fleets, exactly matching the Python AI
  // 10x10: 1:4, 2:3, 3:2, 4:1
  // 9x9 : 3:5, 4:3
  // 8x8 : 2:3, 3:3, 4:1
  const fleetConfigBySize = {
    8:  [
      { len: 2, count: 3 },
      { len: 3, count: 3 },
      { len: 4, count: 1 }
    ],
    9:  [
      { len: 3, count: 5 },
      { len: 4, count: 3 }
    ],
    10: [
      { len: 1, count: 4 },
      { len: 2, count: 3 },
      { len: 3, count: 2 },
      { len: 4, count: 1 }
    ]
  };

  // Current remaining ships: length -> remaining count
  let fleetCounts = {};

  // Modes: miss / hit / sink / clear
  let currentMode = "miss";

  // Characters used by the Python AI
  const DESTROY = "D";
  const EMPTY   = "-";
  const HIT     = "H";
  const MISS    = "^";

  let gameBoardChars = [];   // 2D char board mirroring the Python game_board
  let densityPyramid = [];   // DENSITY_PYRAMID
  let remainingShips = {};   // REMAINING_SHIPS mapping

  // =======================
  // Utility
  // =======================

  function createEmptyBoard(n) {
    const b = [];
    for (let r = 0; r < n; r++) {
      b.push(new Array(n).fill(0));
    }
    return b;
  }

  function initFleetForSize() {
    const cfg = fleetConfigBySize[size] || [];
    fleetCounts = {};
    cfg.forEach(ship => {
      fleetCounts[ship.len] = ship.count;
    });
  }

  function initFleetUI() {
    shipsListEl.innerHTML = "";
    const cfg = fleetConfigBySize[size] || [];
    cfg.forEach(ship => {
      const wrap = document.createElement("div");
      wrap.className = "ship-chip";

      const lenSpan = document.createElement("span");
      lenSpan.className = "len";
      lenSpan.textContent = `Size ${ship.len}`;

      const input = document.createElement("input");
      input.type = "number";
      input.min = "0";
      input.max = String(ship.count);
      input.value = String(fleetCounts[ship.len] ?? ship.count);

      input.addEventListener("input", () => {
        let v = parseInt(input.value || "0", 10);
        if (isNaN(v)) v = 0;
        if (v < 0) v = 0;
        if (v > ship.count) v = ship.count;
        input.value = String(v);
        fleetCounts[ship.len] = v;
        recomputeScores();
      });

      const maxSpan = document.createElement("span");
      maxSpan.className = "max";
      maxSpan.textContent = `(max ${ship.count})`;

      wrap.appendChild(lenSpan);
      wrap.appendChild(input);
      wrap.appendChild(maxSpan);
      shipsListEl.appendChild(wrap);
    });
  }

  function initBoardUI() {
    boardEl.innerHTML = "";
    boardEl.classList.remove("board-size-8", "board-size-9", "board-size-10");
    boardEl.classList.add("board-size-" + size);

    // Top-left corner blank
    const corner = document.createElement("div");
    corner.className = "board-header-cell";
    boardEl.appendChild(corner);

    // Column numbers
    for (let c = 0; c < size; c++) {
      const hdr = document.createElement("div");
      hdr.className = "board-header-cell";
      hdr.textContent = c + 1;
      boardEl.appendChild(hdr);
    }

    // Rows with labels and cells
    for (let r = 0; r < size; r++) {
      const rowLabel = document.createElement("div");
      rowLabel.className = "board-row-label";
      rowLabel.textContent = String.fromCharCode(65 + r);
      boardEl.appendChild(rowLabel);

      for (let c = 0; c < size; c++) {
        const cell = document.createElement("div");
        cell.className = "cell unknown";
        cell.dataset.row = String(r);
        cell.dataset.col = String(c);

        cell.addEventListener("click", () => onCellClick(r, c));

        const bg = document.createElement("div");
        bg.className = "cell-bg";
        cell.appendChild(bg);

        const scoreLabel = document.createElement("div");
        scoreLabel.className = "cell-score";
        cell.appendChild(scoreLabel);

        boardEl.appendChild(cell);
      }
    }
  }

  function onCellClick(r, c) {
    if (currentMode === "miss") {
      board[r][c] = 1;
    } else if (currentMode === "hit") {
      board[r][c] = 2;
    } else if (currentMode === "sink") {
      sinkShipUI(r, c);
    } else if (currentMode === "clear") {
      board[r][c] = 0;
    }
    recomputeScores();
  }

  modeButtons.forEach(btn => {
    btn.addEventListener("click", () => {
      modeButtons.forEach(b => b.classList.remove("active"));
      btn.classList.add("active");
      currentMode = btn.dataset.mode;
    });
  });

  boardSizeSelect.addEventListener("change", () => {
    size = parseInt(boardSizeSelect.value, 10);
    board = createEmptyBoard(size);
    scores = createEmptyBoard(size);
    initFleetForSize();
    initFleetUI();
    initBoardUI();
    recomputeScores();
  });

  resetBoardBtn.addEventListener("click", () => {
    board = createEmptyBoard(size);
    scores = createEmptyBoard(size);
    initFleetForSize();
    initFleetUI();
    initBoardUI();
    recomputeScores();
  });

  // =======================
  // Sink-ship logic (port of sink_ship)
  // =======================

  function sinkShipUI(r, c) {
    // Only works on a hit cell
    if (board[r][c] !== 2) {
      return;
    }

    const sunkenCoords = [];
    // mark starting cell as destroyed
    board[r][c] = 3;
    sunkenCoords.push({ r, c });

    const directions = [
      [0, -1], // left
      [0,  1], // right
      [-1, 0], // up
      [1,  0]  // down
    ];

    // Expand along cardinal directions, turning contiguous hits into destroyed
    directions.forEach(([dr, dc]) => {
      let rr = r + dr;
      let cc = c + dc;
      while (rr >= 0 && rr < size && cc >= 0 && cc < size && board[rr][cc] === 2) {
        board[rr][cc] = 3;
        sunkenCoords.push({ r: rr, c: cc });
        rr += dr;
        cc += dc;
      }
    });

    const shipLen = sunkenCoords.length;

    // Decrement remaining ship count if this length exists
    if (fleetCounts[shipLen] !== undefined && fleetCounts[shipLen] > 0) {
      fleetCounts[shipLen] -= 1;

      // Update the UI input for this ship length
      const cfg = fleetConfigBySize[size] || [];
      const idx = cfg.findIndex(s => s.len === shipLen);
      if (idx !== -1) {
        const inputs = shipsListEl.querySelectorAll("input[type='number']");
        if (inputs[idx]) {
          inputs[idx].value = String(fleetCounts[shipLen]);
        }
      }
    }

    // Now mark all 8-neighbor cells around the sunk ship as misses (if unknown),
    // matching the Python "no ships within 1 tile" behavior.
    const neighborOffsets = [
      [0, -1], [0, 1], [-1, 0], [1, 0],
      [-1, -1], [-1, 1], [1, -1], [1, 1]
    ];

    sunkenCoords.forEach(pos => {
      neighborOffsets.forEach(([dr, dc]) => {
        const rr = pos.r + dr;
        const cc = pos.c + dc;
        if (rr >= 0 && rr < size && cc >= 0 && cc < size) {
          if (board[rr][cc] === 0) {
            board[rr][cc] = 1; // mark as miss
          }
        }
      });
    });
  }

  // =======================
  // Python AI Port (core density logic)
  // =======================

  function buildGameBoardChars() {
    gameBoardChars = [];
    for (let r = 0; r < size; r++) {
      const rowChars = [];
      for (let c = 0; c < size; c++) {
        const v = board[r][c];
        if (v === 1) rowChars.push(MISS);
        else if (v === 2) rowChars.push(HIT);
        else if (v === 3) rowChars.push(DESTROY);
        else rowChars.push(EMPTY);
      }
      gameBoardChars.push(rowChars);
    }
  }

  function buildRemainingShips() {
    remainingShips = {};
    Object.keys(fleetCounts).forEach(lenStr => {
      const len = parseInt(lenStr, 10);
      const count = fleetCounts[len] || 0;
      if (count > 0) {
        remainingShips[len] = count;
      }
    });
  }

  function createDensityPyramid() {
    densityPyramid = [];
    const remainingList = [];
    for (const key in remainingShips) {
      const shipSize = parseInt(key, 10);
      const numRemaining = remainingShips[shipSize];
      if (numRemaining > 0) {
        remainingList.push({ shipSize, numRemaining });
      }
    }

    for (let level = 1; level <= size; level++) {
      const row = new Array(level).fill(0);
      remainingList.forEach(({ shipSize, numRemaining }) => {
        for (let index = 0; index <= level + 1 - shipSize; index++) {
          const rightIndex = index + shipSize - 1;
          if (rightIndex >= level) continue;
          for (let space = index; space <= rightIndex; space++) {
            row[space] += numRemaining;
          }
        }
      });
      densityPyramid.push(row);
    }
  }

  function fillListWithDensityPyramidData(arr, startIndex, sequenceLength) {
    const data = densityPyramid[sequenceLength - 1];
    for (let i = 0; i < sequenceLength; i++) {
      arr[startIndex + i] += data[i];
    }
  }

  function getNumOpenNeighborsInDirection(arr, startIndex, shipSize) {
    // Port of get_num_open_neighbors_in_direction
    let pos = 0;
    let neg = 0;
    let hitsPos = 1;
    let hitsNeg = 1;

    // Extend over contiguous hits
    let idx = startIndex + 1;
    while (idx < arr.length && arr[idx] === HIT && hitsPos < shipSize - 1) {
      hitsPos++;
      idx++;
    }
    idx = startIndex - 1;
    while (idx >= 0 && arr[idx] === HIT && hitsNeg < shipSize - 1) {
      hitsNeg++;
      idx--;
    }

    // Count empty in each direction
    idx = startIndex + 1;
    while (idx < arr.length && arr[idx] === EMPTY && pos < shipSize - hitsNeg) {
      pos++;
      idx++;
    }
    idx = startIndex - 1;
    while (idx >= 0 && arr[idx] === EMPTY && neg < shipSize - hitsPos) {
      neg++;
      idx--;
    }
    return { pos, neg };
  }

  function getNumImmediateNeighbors(row, col) {
    let numOpen = 0;
    for (let dr = -1; dr <= 1; dr++) {
      for (let dc = -1; dc <= 1; dc++) {
        if (dr === 0 && dc === 0) continue;
        const rr = row + dr;
        const cc = col + dc;
        if (rr >= 0 && rr < size && cc >= 0 && cc < size) {
          if (gameBoardChars[rr][cc] === EMPTY) numOpen++;
        }
      }
    }
    return numOpen;
  }

  function generateSpaceDensities() {
    const spaceDensities = [];
    for (let i = 0; i < size; i++) {
      spaceDensities.push(new Array(size).fill(0));
    }

    // Horizontal open sequences
    for (let r = 0; r < size; r++) {
      const row = gameBoardChars[r];
      let nextUnavailable = 0;
      let nextOpen = 0;
      let evaluating = true;

      while (evaluating) {
        while (nextOpen < size && (row[nextOpen] === MISS || row[nextOpen] === DESTROY)) {
          nextOpen++;
        }
        if (nextOpen === size) break;

        while (nextUnavailable < size && (row[nextUnavailable] === EMPTY || row[nextUnavailable] === HIT)) {
          nextUnavailable++;
        }
        const segmentLen = nextUnavailable - nextOpen;
        if (segmentLen > 0) {
          fillListWithDensityPyramidData(spaceDensities[r], nextOpen, segmentLen);
        }

        if (nextUnavailable === size) {
          evaluating = false;
        }
        nextOpen = nextUnavailable + 1;
        nextUnavailable += 1;
      }
    }

    // Vertical open sequences
    for (let c = 0; c < size; c++) {
      const colArr = [];
      for (let r = 0; r < size; r++) {
        colArr.push(gameBoardChars[r][c]);
      }

      let nextUnavailable = 0;
      let nextOpen = 0;
      let evaluating = true;

      while (evaluating) {
        while (nextOpen < size && (colArr[nextOpen] === MISS || colArr[nextOpen] === DESTROY)) {
          nextOpen++;
        }
        if (nextOpen === size) break;

        while (nextUnavailable < size && (colArr[nextUnavailable] === EMPTY || colArr[nextUnavailable] === HIT)) {
          nextUnavailable++;
        }
        const segmentLen = nextUnavailable - nextOpen;
        if (segmentLen > 0) {
          const densityCol = new Array(size).fill(0);
          fillListWithDensityPyramidData(densityCol, nextOpen, segmentLen);
          for (let r = 0; r < size; r++) {
            spaceDensities[r][c] += densityCol[r];
          }
        }

        if (nextUnavailable === size) {
          evaluating = false;
        }
        nextOpen = nextUnavailable + 1;
        nextUnavailable += 1;
      }
    }

    // Neighbor preference (more open neighbors = slightly better)
    for (let r = 0; r < size; r++) {
      for (let c = 0; c < size; c++) {
        const factor = 1 + 0.05 * getNumImmediateNeighbors(r, c);
        spaceDensities[r][c] *= factor;
      }
    }

    // Partial-ship logic like Python
    const remainingKeys = Object.keys(remainingShips)
      .map(k => parseInt(k, 10))
      .filter(k => remainingShips[k] > 0);

    if (remainingKeys.length === 0) return spaceDensities;

    const largestRemainingShipSize = Math.max(...remainingKeys);
    let maxDensity = 0;
    for (let r = 0; r < size; r++) {
      for (let c = 0; c < size; c++) {
        if (spaceDensities[r][c] > maxDensity) maxDensity = spaceDensities[r][c];
      }
    }

    for (let r = 0; r < size; r++) {
      for (let c = 0; c < size; c++) {
        const spot = gameBoardChars[r][c];
        if (spot === HIT) {
          spaceDensities[r][c] = 0;

          const upHit    = (r - 1 >= 0 && gameBoardChars[r - 1][c] === HIT);
          const downHit  = (r + 1 < size && gameBoardChars[r + 1][c] === HIT);
          const leftHit  = (c - 1 >= 0 && gameBoardChars[r][c - 1] === HIT);
          const rightHit = (c + 1 < size && gameBoardChars[r][c + 1] === HIT);

          const colArr = [];
          for (let rr = 0; rr < size; rr++) colArr.push(gameBoardChars[rr][c]);
          const rowArr = gameBoardChars[r];

          if (upHit || downHit) {
            // vertical alignment
            const { pos: downSpace, neg: upSpace } =
              getNumOpenNeighborsInDirection(colArr, r, largestRemainingShipSize);

            if (r - 1 >= 0 && gameBoardChars[r - 1][c] === EMPTY) {
              const factor = 1 + 0.02 * getNumImmediateNeighbors(r - 1, c);
              spaceDensities[r - 1][c] = (maxDensity + upSpace) * factor;
            }
            if (r + 1 < size && gameBoardChars[r + 1][c] === EMPTY) {
              const factor = 1 + 0.02 * getNumImmediateNeighbors(r + 1, c);
              spaceDensities[r + 1][c] = (maxDensity + downSpace) * factor;
            }
          } else if (leftHit || rightHit) {
            // horizontal alignment
            const { pos: rightSpace, neg: leftSpace } =
              getNumOpenNeighborsInDirection(rowArr, c, largestRemainingShipSize);

            if (c - 1 >= 0 && gameBoardChars[r][c - 1] === EMPTY) {
              const factor = 1 + 0.02 * getNumImmediateNeighbors(r, c - 1);
              spaceDensities[r][c - 1] = (maxDensity + leftSpace) * factor;
            }
            if (c + 1 < size && gameBoardChars[r][c + 1] === EMPTY) {
              const factor = 1 + 0.02 * getNumImmediateNeighbors(r, c + 1);
              spaceDensities[r][c + 1] = (maxDensity + rightSpace) * factor;
            }
          } else {
            // single hit, unknown orientation
            const { pos: downSpace, neg: upSpace } =
              getNumOpenNeighborsInDirection(colArr, r, largestRemainingShipSize);
            const { pos: rightSpace, neg: leftSpace } =
              getNumOpenNeighborsInDirection(rowArr, c, largestRemainingShipSize);

            if (r - 1 >= 0 && gameBoardChars[r - 1][c] === EMPTY) {
              const factor = 1 + 0.02 * getNumImmediateNeighbors(r - 1, c);
              spaceDensities[r - 1][c] = (maxDensity + upSpace) * factor;
            }
            if (r + 1 < size && gameBoardChars[r + 1][c] === EMPTY) {
              const factor = 1 + 0.02 * getNumImmediateNeighbors(r + 1, c);
              spaceDensities[r + 1][c] = (maxDensity + downSpace) * factor;
            }
            if (c - 1 >= 0 && gameBoardChars[r][c - 1] === EMPTY) {
              const factor = 1 + 0.02 * getNumImmediateNeighbors(r, c - 1);
              spaceDensities[r][c - 1] = (maxDensity + leftSpace) * factor;
            }
            if (c + 1 < size && gameBoardChars[r][c + 1] === EMPTY) {
              const factor = 1 + 0.02 * getNumImmediateNeighbors(r, c + 1);
              spaceDensities[r][c + 1] = (maxDensity + rightSpace) * factor;
            }
          }
        }
      }
    }

    return spaceDensities;
  }

  function recomputeScores() {
    buildGameBoardChars();
    buildRemainingShips();

    if (Object.keys(remainingShips).length === 0) {
      scores = createEmptyBoard(size);
      updateBoardUI();
      bestShotsEl.innerHTML = "";
      statusText.textContent = "No ships selected (all counts are 0). Increase remaining ship counts to see probabilities.";
      return;
    }

    createDensityPyramid();
    scores = generateSpaceDensities();
    updateBoardUI();
    updateBestShots();
  }

  // =======================
  // UI update
  // =======================

  function updateBoardUI() {
    let maxScore = 0;
    for (let r = 0; r < size; r++) {
      for (let c = 0; c < size; c++) {
        if (scores[r][c] > maxScore) maxScore = scores[r][c];
      }
    }

    const cells = boardEl.querySelectorAll(".cell");
    cells.forEach(cell => {
      const r = parseInt(cell.dataset.row, 10);
      const c = parseInt(cell.dataset.col, 10);
      const state = board[r][c];
      const score = scores[r][c];

      cell.classList.remove("unknown", "miss", "hit", "destroy", "best");

      if (state === 1) {
        cell.classList.add("miss");
      } else if (state === 2) {
        cell.classList.add("hit");
      } else if (state === 3) {
        cell.classList.add("destroy");
      } else {
        cell.classList.add("unknown");
      }

      const bg = cell.querySelector(".cell-bg");
      const scoreLabel = cell.querySelector(".cell-score");

      if (maxScore > 0 && score > 0 && state === 0) {
        const t = score / maxScore;
        const clamped = Math.max(0, Math.min(1, t));
        const rCol = Math.round(32 + 80 * clamped);
        const gCol = Math.round(80 + 140 * clamped);
        const bCol = Math.round(48 + 40 * clamped);
        bg.style.background = `rgb(${rCol}, ${gCol}, ${bCol})`;
        bg.style.opacity = 0.9;
        scoreLabel.textContent = score.toFixed(0);
      } else {
        bg.style.background = "transparent";
        bg.style.opacity = 0;
        scoreLabel.textContent = "";
      }
    });
  }

  function coordFromRC(r, c) {
    return String.fromCharCode(65 + r) + (c + 1);
  }

  function getCellElement(r, c) {
    return boardEl.querySelector(`.cell[data-row="${r}"][data-col="${c}"]`);
  }

  function updateBestShots() {
    let maxScore = 0;
    const candidates = [];

    for (let r = 0; r < size; r++) {
      for (let c = 0; c < size; c++) {
        if (board[r][c] === 0 && scores[r][c] > maxScore) {
          maxScore = scores[r][c];
        }
      }
    }

    const allCells = boardEl.querySelectorAll(".cell");
    allCells.forEach(cell => cell.classList.remove("best"));

    bestShotsEl.innerHTML = "";

    if (maxScore <= 0) {
      statusText.textContent = "Mark some misses/hits and set remaining ships to see the best moves.";
      return;
    }

    for (let r = 0; r < size; r++) {
      for (let c = 0; c < size; c++) {
        if (board[r][c] === 0 && scores[r][c] === maxScore) {
          candidates.push({ r, c });
        }
      }
    }

    const top = candidates.slice(0, 5);
    top.forEach(pos => {
      const coord = coordFromRC(pos.r, pos.c);
      const span = document.createElement("span");
      span.className = "coord";
      span.textContent = coord;
      bestShotsEl.appendChild(span);

      const cell = getCellElement(pos.r, pos.c);
      if (cell) cell.classList.add("best");
    });

    statusText.textContent = "Highest probability squares based on Sea Battle rules:";
  }

  // =======================
  // Init
  // =======================

  initFleetForSize();
  initFleetUI();
  initBoardUI();
  recomputeScores();
</script>
</body>
</html>
